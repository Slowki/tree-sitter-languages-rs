use git2::Repository;
use std::cmp::Ordering;
use std::path::Path;

static BASE_URL: &'static str = "https://github.com/tree-sitter/tree-sitter-";

/// Get the highest tagged version
///
/// #### Note
/// Expects tags in the format v#.#.#
fn get_highest<'a>(tags: impl Iterator<Item = &'a str>) -> Option<&'a str> {
    let mut pairs: Vec<(Vec<i32>, &'a str)> = tags
        .filter(|s| s.starts_with('v'))
        .map(|s| {
            (
                s[1..]
                    .split(".")
                    .map(|x| x.parse::<i32>().ok())
                    .collect::<Vec<Option<i32>>>(),
                s,
            )
        })
        .filter(|(vs, _)| vs.iter().all(|x| x.is_some()))
        .map(|(vs, s)| (vs.into_iter().map(|x| x.unwrap()).collect::<Vec<i32>>(), s))
        .collect();
    pairs.sort_by(|(x, _), (y, _)| {
        let mut idx = 0;
        while idx < x.len() && idx < y.len() {
            if x[idx] < y[idx] {
                return Ordering::Less;
            } else if x[idx] > y[idx] {
                return Ordering::Greater;
            }
            idx += 1;
        }
        if x.len() < y.len() {
            Ordering::Less
        } else if x.len() > y.len() {
            Ordering::Greater
        } else {
            Ordering::Equal
        }
    });

    return pairs.last().map(|x| x.1);
}

fn build_language(name: &'static str, branch: Option<&'static str>, subdir: Option<&'static str>) {
    let repo_dir = Path::new(name);
    println!("Building {}", name);

    let repo = if !repo_dir.exists() {
        let url = std::format!("{}{}.git", BASE_URL, name);
        println!("Cloning {}", url);
        match Repository::clone(&url, &repo_dir) {
            Ok(repo) => repo,
            Err(e) => panic!("Clone {} failed: {}", url, e),
        }
    } else {
        match Repository::open(&repo_dir) {
            Ok(repo) => repo,
            Err(e) => panic!(
                "Failed to open repo at {}: {}",
                repo_dir.to_str().unwrap(),
                e
            ),
        }
    };

    let branch_or_tag = match branch {
        None => get_highest(
            repo.tag_names(Some("v*"))
                .expect("Couldn't get tags")
                .into_iter()
                .map(|s| s.unwrap()),
        )
        .unwrap_or("master")
        .to_owned(),
        Some(branch) => branch.to_owned(),
    };

    println!("Checking out {}", &branch_or_tag);
    let object = repo.revparse_single(&branch_or_tag).unwrap();
    repo.set_head_detached(object.id()).unwrap();
    repo.checkout_head(Some(
        git2::build::CheckoutBuilder::new()
            .force()
            .remove_ignored(true)
            .remove_untracked(true),
    ))
    .unwrap();

    let source_directory = match subdir {
        Some(dir) => repo_dir.join(dir).join("src"),
        None => repo_dir.join("src"),
    };

    let mut c_files = Vec::new();
    let mut cxx_files = Vec::new();
    &source_directory
        .read_dir()
        .unwrap()
        .for_each(&mut |maybe_path: std::io::Result<std::fs::DirEntry>| {
            let path = maybe_path.unwrap().path();
            if let Some(extension) = path.extension() {
                if extension == "c" {
                    c_files.push(path);
                } else if path.file_stem().unwrap() != "binding"
                    && (extension == "cc" || extension == "cpp" || extension == "cxx")
                {
                    cxx_files.push(path);
                }
            }
        });

    if c_files.len() == 0 {
        panic!("Didn't find any C files in {:?}", &source_directory);
    }

    if cxx_files.len() > 0 {
        cc::Build::new()
            .files(cxx_files.iter())
            .static_flag(true)
            .cpp(true)
            .warnings(false)
            .include(&source_directory)
            .compile(format!("libtree_sitter_{}_helpers.a", name).as_str());
    }

    cc::Build::new()
        .files(c_files.iter())
        .static_flag(true)
        .warnings(false)
        .include(&source_directory)
        .compile(format!("libtree_sitter_{}.a", name).as_str());
}

fn main() {
    // This function is generated by scripts/generate
    let mut version_map: std::collections::BTreeMap<&'static str, &'static str> =
        std::collections::BTreeMap::new();
    if cfg!(feature = "go-latest") {
        if let Some(conflicting) = version_map.get("go") {
            panic!("go-latest conflicts with {}", conflicting);
        }
        version_map.insert("go", "go-latest");
        build_language("go", None, None);
    }
    if cfg!(feature = "javascript-latest") {
        if let Some(conflicting) = version_map.get("javascript") {
            panic!("javascript-latest conflicts with {}", conflicting);
        }
        version_map.insert("javascript", "javascript-latest");
        build_language("javascript", None, None);
    }
    if cfg!(feature = "regex-master") {
        if let Some(conflicting) = version_map.get("regex") {
            panic!("regex-master conflicts with {}", conflicting);
        }
        version_map.insert("regex", "regex-master");
        build_language("regex", Some("master"), None);
    }
    if cfg!(feature = "julia-latest") {
        if let Some(conflicting) = version_map.get("julia") {
            panic!("julia-latest conflicts with {}", conflicting);
        }
        version_map.insert("julia", "julia-latest");
        build_language("julia", None, None);
    }
    if cfg!(feature = "cpp-latest") {
        if let Some(conflicting) = version_map.get("cpp") {
            panic!("cpp-latest conflicts with {}", conflicting);
        }
        version_map.insert("cpp", "cpp-latest");
        build_language("cpp", None, None);
    }
    if cfg!(feature = "c-latest") {
        if let Some(conflicting) = version_map.get("c") {
            panic!("c-latest conflicts with {}", conflicting);
        }
        version_map.insert("c", "c-latest");
        build_language("c", None, None);
    }
    if cfg!(feature = "ocaml-latest") {
        if let Some(conflicting) = version_map.get("ocaml") {
            panic!("ocaml-latest conflicts with {}", conflicting);
        }
        version_map.insert("ocaml", "ocaml-latest");
        build_language("ocaml", None, None);
    }
    if cfg!(feature = "julia-master") {
        if let Some(conflicting) = version_map.get("julia") {
            panic!("julia-master conflicts with {}", conflicting);
        }
        version_map.insert("julia", "julia-master");
        build_language("julia", Some("master"), None);
    }
    if cfg!(feature = "cpp-master") {
        if let Some(conflicting) = version_map.get("cpp") {
            panic!("cpp-master conflicts with {}", conflicting);
        }
        version_map.insert("cpp", "cpp-master");
        build_language("cpp", Some("master"), None);
    }
    if cfg!(feature = "c-master") {
        if let Some(conflicting) = version_map.get("c") {
            panic!("c-master conflicts with {}", conflicting);
        }
        version_map.insert("c", "c-master");
        build_language("c", Some("master"), None);
    }
    if cfg!(feature = "rust-latest") {
        if let Some(conflicting) = version_map.get("rust") {
            panic!("rust-latest conflicts with {}", conflicting);
        }
        version_map.insert("rust", "rust-latest");
        build_language("rust", None, None);
    }
    if cfg!(feature = "bash-latest") {
        if let Some(conflicting) = version_map.get("bash") {
            panic!("bash-latest conflicts with {}", conflicting);
        }
        version_map.insert("bash", "bash-latest");
        build_language("bash", None, None);
    }
    if cfg!(feature = "css-master") {
        if let Some(conflicting) = version_map.get("css") {
            panic!("css-master conflicts with {}", conflicting);
        }
        version_map.insert("css", "css-master");
        build_language("css", Some("master"), None);
    }
    if cfg!(feature = "css-latest") {
        if let Some(conflicting) = version_map.get("css") {
            panic!("css-latest conflicts with {}", conflicting);
        }
        version_map.insert("css", "css-latest");
        build_language("css", None, None);
    }
    if cfg!(feature = "java-master") {
        if let Some(conflicting) = version_map.get("java") {
            panic!("java-master conflicts with {}", conflicting);
        }
        version_map.insert("java", "java-master");
        build_language("java", Some("master"), None);
    }
    if cfg!(feature = "fluent-master") {
        if let Some(conflicting) = version_map.get("fluent") {
            panic!("fluent-master conflicts with {}", conflicting);
        }
        version_map.insert("fluent", "fluent-master");
        build_language("fluent", Some("master"), None);
    }
    if cfg!(feature = "c-sharp-master") {
        if let Some(conflicting) = version_map.get("c-sharp") {
            panic!("c-sharp-master conflicts with {}", conflicting);
        }
        version_map.insert("c-sharp", "c-sharp-master");
        build_language("c-sharp", Some("master"), None);
    }
    if cfg!(feature = "fluent-latest") {
        if let Some(conflicting) = version_map.get("fluent") {
            panic!("fluent-latest conflicts with {}", conflicting);
        }
        version_map.insert("fluent", "fluent-latest");
        build_language("fluent", None, None);
    }
    if cfg!(feature = "python-latest") {
        if let Some(conflicting) = version_map.get("python") {
            panic!("python-latest conflicts with {}", conflicting);
        }
        version_map.insert("python", "python-latest");
        build_language("python", None, None);
    }
    if cfg!(feature = "regex-latest") {
        if let Some(conflicting) = version_map.get("regex") {
            panic!("regex-latest conflicts with {}", conflicting);
        }
        version_map.insert("regex", "regex-latest");
        build_language("regex", None, None);
    }
    if cfg!(feature = "ocaml-master") {
        if let Some(conflicting) = version_map.get("ocaml") {
            panic!("ocaml-master conflicts with {}", conflicting);
        }
        version_map.insert("ocaml", "ocaml-master");
        build_language("ocaml", Some("master"), None);
    }
    if cfg!(feature = "ruby-latest") {
        if let Some(conflicting) = version_map.get("ruby") {
            panic!("ruby-latest conflicts with {}", conflicting);
        }
        version_map.insert("ruby", "ruby-latest");
        build_language("ruby", None, None);
    }
    if cfg!(feature = "jsdoc-master") {
        if let Some(conflicting) = version_map.get("jsdoc") {
            panic!("jsdoc-master conflicts with {}", conflicting);
        }
        version_map.insert("jsdoc", "jsdoc-master");
        build_language("jsdoc", Some("master"), None);
    }
    if cfg!(feature = "jsdoc-latest") {
        if let Some(conflicting) = version_map.get("jsdoc") {
            panic!("jsdoc-latest conflicts with {}", conflicting);
        }
        version_map.insert("jsdoc", "jsdoc-latest");
        build_language("jsdoc", None, None);
    }
    if cfg!(feature = "rust-master") {
        if let Some(conflicting) = version_map.get("rust") {
            panic!("rust-master conflicts with {}", conflicting);
        }
        version_map.insert("rust", "rust-master");
        build_language("rust", Some("master"), None);
    }
    if cfg!(feature = "bash-master") {
        if let Some(conflicting) = version_map.get("bash") {
            panic!("bash-master conflicts with {}", conflicting);
        }
        version_map.insert("bash", "bash-master");
        build_language("bash", Some("master"), None);
    }
    if cfg!(feature = "agda-master") {
        if let Some(conflicting) = version_map.get("agda") {
            panic!("agda-master conflicts with {}", conflicting);
        }
        version_map.insert("agda", "agda-master");
        build_language("agda", Some("master"), None);
    }
    if cfg!(feature = "json-master") {
        if let Some(conflicting) = version_map.get("json") {
            panic!("json-master conflicts with {}", conflicting);
        }
        version_map.insert("json", "json-master");
        build_language("json", Some("master"), None);
    }
    if cfg!(feature = "agda-latest") {
        if let Some(conflicting) = version_map.get("agda") {
            panic!("agda-latest conflicts with {}", conflicting);
        }
        version_map.insert("agda", "agda-latest");
        build_language("agda", None, None);
    }
    if cfg!(feature = "json-latest") {
        if let Some(conflicting) = version_map.get("json") {
            panic!("json-latest conflicts with {}", conflicting);
        }
        version_map.insert("json", "json-latest");
        build_language("json", None, None);
    }
    if cfg!(feature = "haskell-master") {
        if let Some(conflicting) = version_map.get("haskell") {
            panic!("haskell-master conflicts with {}", conflicting);
        }
        version_map.insert("haskell", "haskell-master");
        build_language("haskell", Some("master"), None);
    }
    if cfg!(feature = "haskell-latest") {
        if let Some(conflicting) = version_map.get("haskell") {
            panic!("haskell-latest conflicts with {}", conflicting);
        }
        version_map.insert("haskell", "haskell-latest");
        build_language("haskell", None, None);
    }
    if cfg!(feature = "ruby-master") {
        if let Some(conflicting) = version_map.get("ruby") {
            panic!("ruby-master conflicts with {}", conflicting);
        }
        version_map.insert("ruby", "ruby-master");
        build_language("ruby", Some("master"), None);
    }
    if cfg!(feature = "scala-latest") {
        if let Some(conflicting) = version_map.get("scala") {
            panic!("scala-latest conflicts with {}", conflicting);
        }
        version_map.insert("scala", "scala-latest");
        build_language("scala", None, None);
    }
    if cfg!(feature = "python-master") {
        if let Some(conflicting) = version_map.get("python") {
            panic!("python-master conflicts with {}", conflicting);
        }
        version_map.insert("python", "python-master");
        build_language("python", Some("master"), None);
    }
    if cfg!(feature = "javascript-master") {
        if let Some(conflicting) = version_map.get("javascript") {
            panic!("javascript-master conflicts with {}", conflicting);
        }
        version_map.insert("javascript", "javascript-master");
        build_language("javascript", Some("master"), None);
    }
    if cfg!(feature = "scala-master") {
        if let Some(conflicting) = version_map.get("scala") {
            panic!("scala-master conflicts with {}", conflicting);
        }
        version_map.insert("scala", "scala-master");
        build_language("scala", Some("master"), None);
    }
    if cfg!(feature = "go-master") {
        if let Some(conflicting) = version_map.get("go") {
            panic!("go-master conflicts with {}", conflicting);
        }
        version_map.insert("go", "go-master");
        build_language("go", Some("master"), None);
    }
    if cfg!(feature = "c-sharp-latest") {
        if let Some(conflicting) = version_map.get("c-sharp") {
            panic!("c-sharp-latest conflicts with {}", conflicting);
        }
        version_map.insert("c-sharp", "c-sharp-latest");
        build_language("c-sharp", None, None);
    }
    if cfg!(feature = "java-latest") {
        if let Some(conflicting) = version_map.get("java") {
            panic!("java-latest conflicts with {}", conflicting);
        }
        version_map.insert("java", "java-latest");
        build_language("java", None, None);
    }
}
