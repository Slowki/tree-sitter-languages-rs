#!bash
set -e
ROOT_DIR=$(dirname $(dirname $(realpath ${BASH_SOURCE[0]})))
languages=$(cat $ROOT_DIR/languages | grep -vi "^#")
declare -A feature_language
declare -A feature_enum
declare -A language_to_features

function generate-features() {
    echo "[features]"
    echo "# These flags are generated by scripts/generate"
    echo "default = []"
    all="all = ["
    for entry in $languages; do
        # Todo generate a feature for git tag
        echo "$entry = [\"$entry-latest\"] # Alias for $entry-latest"
        echo "$entry-latest = [] # Use the latest tagged version"
        echo "$entry-master = [] # Use the master branch"
        all+=", \"$entry-latest\""
        feature_language[$entry-latest]=$entry
        feature_language[$entry-master]=$entry
        feature_enum[$entry-latest]="None"
        feature_enum[$entry-master]="Some(\"master\")"
	language_to_features[$entry]="$entry-latest $entry-master"
    done
    echo "$all]" | sed "s/\[,\s*/[/"
}

function generate-build-rs() {
    echo "fn main() {"
    echo "    // This function is generated by scripts/generate"
    echo "    let mut version_map: std::collections::BTreeMap<&'static str, &'static str> = std::collections::BTreeMap::new();"

    for feature in "${!feature_language[@]}"; do
        cat <<EOF
    if cfg!(feature = "$feature") {
        if let Some(conflicting) = version_map.get("${feature_language[$feature]}") {
            panic!("$feature conflicts with {}", conflicting);
        }
        version_map.insert("${feature_language[$feature]}", "$feature");
        build_language("${feature_language[$feature]}", ${feature_enum[$feature]}, None);
    }
EOF
    done
    echo "}" 
}

function generate-lib-rs() {
    echo "// This code is generated by scripts/generate"
    for language in "${!language_to_features[@]}"; do
	language_ident=$(echo $language | sed "s/-/_/g")

        feature_checks=""
        for feature in ${language_to_features[$language]}; do
            feature_checks+=", feature = \"$feature\""
        done
        feature_checks=$(echo $feature_checks | sed "s/^,\s*//")

        cat <<EOF
    #[cfg(any($feature_checks))]
    /// Get a \`tree_sitter::Language\` instance for ${feature_language[$feature]}
    ///
    /// #### Note
    /// Requires the ${feature_language[$feature]} feature (or one of the ${feature_language[$feature]}-* features, like ${feature_language[$feature]}-master)
    pub fn get_${language_ident}() -> tree_sitter::Language {
        extern "C" { fn tree_sitter_$language_ident() -> tree_sitter::Language; }

        unsafe { tree_sitter_$language_ident() }
    }

    #[cfg(not(any($feature_checks)))]
    /// A stub function which just panics so the type checker passes. This function can be enabled
    /// via the ${feature_language[$feature]} feature flags.
    pub fn get_${language_ident}() -> tree_sitter::Language {
        panic!("${feature_language[$feature]} isn't available, to call this function you need to change your feature flags.")
    }

    #[cfg(any($feature_checks))]
    #[macro_export]
    /// Check whether or not ${language_ident} is enabled
    macro_rules! ${language_ident}_is_available {
        () => (true)
    }

    #[cfg(not(any($feature_checks)))]
    #[macro_export]
    /// Check whether or not ${language_ident} is enabled
    macro_rules! ${language_ident}_is_available {
        () => (false)
    }
EOF
    done
}

gitignore_comment="# repositories list"
function generate-gitignore() {
    echo $gitignore_comment
    for entry in $languages; do
        echo "/$entry"
    done
}

sed -i '/\[features\]/,$d' $ROOT_DIR/Cargo.toml
generate-features >> $ROOT_DIR/Cargo.toml

sed -i '/fn main() {/,$d' $ROOT_DIR/build.rs
generate-build-rs >> $ROOT_DIR/build.rs

generate-lib-rs > $ROOT_DIR/src/lib.rs

sed -i "/$gitignore_comment/,\$d" $ROOT_DIR/.gitignore
generate-gitignore >> $ROOT_DIR/.gitignore

cd $ROOT_DIR
cargo fmt
