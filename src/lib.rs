// This code is generated by scripts/generate
#[cfg(any(feature = "go-latest", feature = "go-master"))]
/// Get a `tree_sitter::Language` instance for go
///
/// #### Note
/// Requires the go feature (or one of the go-* features, like go-master)
pub fn get_go() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_go() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_go() }
}

#[cfg(not(any(feature = "go-latest", feature = "go-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the go feature flags.
pub fn get_go() -> tree_sitter::Language {
    panic!("go isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "go-latest", feature = "go-master"))]
#[macro_export]
/// Check whether or not go is enabled
macro_rules! go_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "go-latest", feature = "go-master")))]
#[macro_export]
/// Check whether or not go is enabled
macro_rules! go_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "jsdoc-latest", feature = "jsdoc-master"))]
/// Get a `tree_sitter::Language` instance for jsdoc
///
/// #### Note
/// Requires the jsdoc feature (or one of the jsdoc-* features, like jsdoc-master)
pub fn get_jsdoc() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_jsdoc() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_jsdoc() }
}

#[cfg(not(any(feature = "jsdoc-latest", feature = "jsdoc-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the jsdoc feature flags.
pub fn get_jsdoc() -> tree_sitter::Language {
    panic!("jsdoc isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "jsdoc-latest", feature = "jsdoc-master"))]
#[macro_export]
/// Check whether or not jsdoc is enabled
macro_rules! jsdoc_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "jsdoc-latest", feature = "jsdoc-master")))]
#[macro_export]
/// Check whether or not jsdoc is enabled
macro_rules! jsdoc_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "json-latest", feature = "json-master"))]
/// Get a `tree_sitter::Language` instance for json
///
/// #### Note
/// Requires the json feature (or one of the json-* features, like json-master)
pub fn get_json() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_json() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_json() }
}

#[cfg(not(any(feature = "json-latest", feature = "json-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the json feature flags.
pub fn get_json() -> tree_sitter::Language {
    panic!("json isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "json-latest", feature = "json-master"))]
#[macro_export]
/// Check whether or not json is enabled
macro_rules! json_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "json-latest", feature = "json-master")))]
#[macro_export]
/// Check whether or not json is enabled
macro_rules! json_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "c-sharp-latest", feature = "c-sharp-master"))]
/// Get a `tree_sitter::Language` instance for c-sharp
///
/// #### Note
/// Requires the c-sharp feature (or one of the c-sharp-* features, like c-sharp-master)
pub fn get_c_sharp() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_c_sharp() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_c_sharp() }
}

#[cfg(not(any(feature = "c-sharp-latest", feature = "c-sharp-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the c-sharp feature flags.
pub fn get_c_sharp() -> tree_sitter::Language {
    panic!("c-sharp isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "c-sharp-latest", feature = "c-sharp-master"))]
#[macro_export]
/// Check whether or not c_sharp is enabled
macro_rules! c_sharp_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "c-sharp-latest", feature = "c-sharp-master")))]
#[macro_export]
/// Check whether or not c_sharp is enabled
macro_rules! c_sharp_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "java-latest", feature = "java-master"))]
/// Get a `tree_sitter::Language` instance for java
///
/// #### Note
/// Requires the java feature (or one of the java-* features, like java-master)
pub fn get_java() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_java() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_java() }
}

#[cfg(not(any(feature = "java-latest", feature = "java-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the java feature flags.
pub fn get_java() -> tree_sitter::Language {
    panic!("java isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "java-latest", feature = "java-master"))]
#[macro_export]
/// Check whether or not java is enabled
macro_rules! java_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "java-latest", feature = "java-master")))]
#[macro_export]
/// Check whether or not java is enabled
macro_rules! java_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "rust-latest", feature = "rust-master"))]
/// Get a `tree_sitter::Language` instance for rust
///
/// #### Note
/// Requires the rust feature (or one of the rust-* features, like rust-master)
pub fn get_rust() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_rust() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_rust() }
}

#[cfg(not(any(feature = "rust-latest", feature = "rust-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the rust feature flags.
pub fn get_rust() -> tree_sitter::Language {
    panic!("rust isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "rust-latest", feature = "rust-master"))]
#[macro_export]
/// Check whether or not rust is enabled
macro_rules! rust_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "rust-latest", feature = "rust-master")))]
#[macro_export]
/// Check whether or not rust is enabled
macro_rules! rust_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "bash-latest", feature = "bash-master"))]
/// Get a `tree_sitter::Language` instance for bash
///
/// #### Note
/// Requires the bash feature (or one of the bash-* features, like bash-master)
pub fn get_bash() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_bash() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_bash() }
}

#[cfg(not(any(feature = "bash-latest", feature = "bash-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the bash feature flags.
pub fn get_bash() -> tree_sitter::Language {
    panic!("bash isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "bash-latest", feature = "bash-master"))]
#[macro_export]
/// Check whether or not bash is enabled
macro_rules! bash_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "bash-latest", feature = "bash-master")))]
#[macro_export]
/// Check whether or not bash is enabled
macro_rules! bash_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "regex-latest", feature = "regex-master"))]
/// Get a `tree_sitter::Language` instance for regex
///
/// #### Note
/// Requires the regex feature (or one of the regex-* features, like regex-master)
pub fn get_regex() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_regex() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_regex() }
}

#[cfg(not(any(feature = "regex-latest", feature = "regex-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the regex feature flags.
pub fn get_regex() -> tree_sitter::Language {
    panic!("regex isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "regex-latest", feature = "regex-master"))]
#[macro_export]
/// Check whether or not regex is enabled
macro_rules! regex_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "regex-latest", feature = "regex-master")))]
#[macro_export]
/// Check whether or not regex is enabled
macro_rules! regex_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "css-latest", feature = "css-master"))]
/// Get a `tree_sitter::Language` instance for css
///
/// #### Note
/// Requires the css feature (or one of the css-* features, like css-master)
pub fn get_css() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_css() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_css() }
}

#[cfg(not(any(feature = "css-latest", feature = "css-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the css feature flags.
pub fn get_css() -> tree_sitter::Language {
    panic!("css isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "css-latest", feature = "css-master"))]
#[macro_export]
/// Check whether or not css is enabled
macro_rules! css_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "css-latest", feature = "css-master")))]
#[macro_export]
/// Check whether or not css is enabled
macro_rules! css_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "agda-latest", feature = "agda-master"))]
/// Get a `tree_sitter::Language` instance for agda
///
/// #### Note
/// Requires the agda feature (or one of the agda-* features, like agda-master)
pub fn get_agda() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_agda() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_agda() }
}

#[cfg(not(any(feature = "agda-latest", feature = "agda-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the agda feature flags.
pub fn get_agda() -> tree_sitter::Language {
    panic!("agda isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "agda-latest", feature = "agda-master"))]
#[macro_export]
/// Check whether or not agda is enabled
macro_rules! agda_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "agda-latest", feature = "agda-master")))]
#[macro_export]
/// Check whether or not agda is enabled
macro_rules! agda_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "scala-latest", feature = "scala-master"))]
/// Get a `tree_sitter::Language` instance for scala
///
/// #### Note
/// Requires the scala feature (or one of the scala-* features, like scala-master)
pub fn get_scala() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_scala() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_scala() }
}

#[cfg(not(any(feature = "scala-latest", feature = "scala-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the scala feature flags.
pub fn get_scala() -> tree_sitter::Language {
    panic!("scala isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "scala-latest", feature = "scala-master"))]
#[macro_export]
/// Check whether or not scala is enabled
macro_rules! scala_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "scala-latest", feature = "scala-master")))]
#[macro_export]
/// Check whether or not scala is enabled
macro_rules! scala_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "python-latest", feature = "python-master"))]
/// Get a `tree_sitter::Language` instance for python
///
/// #### Note
/// Requires the python feature (or one of the python-* features, like python-master)
pub fn get_python() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_python() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_python() }
}

#[cfg(not(any(feature = "python-latest", feature = "python-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the python feature flags.
pub fn get_python() -> tree_sitter::Language {
    panic!("python isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "python-latest", feature = "python-master"))]
#[macro_export]
/// Check whether or not python is enabled
macro_rules! python_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "python-latest", feature = "python-master")))]
#[macro_export]
/// Check whether or not python is enabled
macro_rules! python_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "ruby-latest", feature = "ruby-master"))]
/// Get a `tree_sitter::Language` instance for ruby
///
/// #### Note
/// Requires the ruby feature (or one of the ruby-* features, like ruby-master)
pub fn get_ruby() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_ruby() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_ruby() }
}

#[cfg(not(any(feature = "ruby-latest", feature = "ruby-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the ruby feature flags.
pub fn get_ruby() -> tree_sitter::Language {
    panic!("ruby isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "ruby-latest", feature = "ruby-master"))]
#[macro_export]
/// Check whether or not ruby is enabled
macro_rules! ruby_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "ruby-latest", feature = "ruby-master")))]
#[macro_export]
/// Check whether or not ruby is enabled
macro_rules! ruby_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "ocaml-latest", feature = "ocaml-master"))]
/// Get a `tree_sitter::Language` instance for ocaml
///
/// #### Note
/// Requires the ocaml feature (or one of the ocaml-* features, like ocaml-master)
pub fn get_ocaml() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_ocaml() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_ocaml() }
}

#[cfg(not(any(feature = "ocaml-latest", feature = "ocaml-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the ocaml feature flags.
pub fn get_ocaml() -> tree_sitter::Language {
    panic!("ocaml isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "ocaml-latest", feature = "ocaml-master"))]
#[macro_export]
/// Check whether or not ocaml is enabled
macro_rules! ocaml_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "ocaml-latest", feature = "ocaml-master")))]
#[macro_export]
/// Check whether or not ocaml is enabled
macro_rules! ocaml_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "haskell-latest", feature = "haskell-master"))]
/// Get a `tree_sitter::Language` instance for haskell
///
/// #### Note
/// Requires the haskell feature (or one of the haskell-* features, like haskell-master)
pub fn get_haskell() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_haskell() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_haskell() }
}

#[cfg(not(any(feature = "haskell-latest", feature = "haskell-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the haskell feature flags.
pub fn get_haskell() -> tree_sitter::Language {
    panic!("haskell isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "haskell-latest", feature = "haskell-master"))]
#[macro_export]
/// Check whether or not haskell is enabled
macro_rules! haskell_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "haskell-latest", feature = "haskell-master")))]
#[macro_export]
/// Check whether or not haskell is enabled
macro_rules! haskell_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "javascript-latest", feature = "javascript-master"))]
/// Get a `tree_sitter::Language` instance for javascript
///
/// #### Note
/// Requires the javascript feature (or one of the javascript-* features, like javascript-master)
pub fn get_javascript() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_javascript() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_javascript() }
}

#[cfg(not(any(feature = "javascript-latest", feature = "javascript-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the javascript feature flags.
pub fn get_javascript() -> tree_sitter::Language {
    panic!(
        "javascript isn't available, to call this function you need to change your feature flags."
    )
}

#[cfg(any(feature = "javascript-latest", feature = "javascript-master"))]
#[macro_export]
/// Check whether or not javascript is enabled
macro_rules! javascript_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "javascript-latest", feature = "javascript-master")))]
#[macro_export]
/// Check whether or not javascript is enabled
macro_rules! javascript_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "fluent-latest", feature = "fluent-master"))]
/// Get a `tree_sitter::Language` instance for fluent
///
/// #### Note
/// Requires the fluent feature (or one of the fluent-* features, like fluent-master)
pub fn get_fluent() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_fluent() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_fluent() }
}

#[cfg(not(any(feature = "fluent-latest", feature = "fluent-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the fluent feature flags.
pub fn get_fluent() -> tree_sitter::Language {
    panic!("fluent isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "fluent-latest", feature = "fluent-master"))]
#[macro_export]
/// Check whether or not fluent is enabled
macro_rules! fluent_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "fluent-latest", feature = "fluent-master")))]
#[macro_export]
/// Check whether or not fluent is enabled
macro_rules! fluent_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "julia-latest", feature = "julia-master"))]
/// Get a `tree_sitter::Language` instance for julia
///
/// #### Note
/// Requires the julia feature (or one of the julia-* features, like julia-master)
pub fn get_julia() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_julia() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_julia() }
}

#[cfg(not(any(feature = "julia-latest", feature = "julia-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the julia feature flags.
pub fn get_julia() -> tree_sitter::Language {
    panic!("julia isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "julia-latest", feature = "julia-master"))]
#[macro_export]
/// Check whether or not julia is enabled
macro_rules! julia_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "julia-latest", feature = "julia-master")))]
#[macro_export]
/// Check whether or not julia is enabled
macro_rules! julia_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "cpp-latest", feature = "cpp-master"))]
/// Get a `tree_sitter::Language` instance for cpp
///
/// #### Note
/// Requires the cpp feature (or one of the cpp-* features, like cpp-master)
pub fn get_cpp() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_cpp() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_cpp() }
}

#[cfg(not(any(feature = "cpp-latest", feature = "cpp-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the cpp feature flags.
pub fn get_cpp() -> tree_sitter::Language {
    panic!("cpp isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "cpp-latest", feature = "cpp-master"))]
#[macro_export]
/// Check whether or not cpp is enabled
macro_rules! cpp_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "cpp-latest", feature = "cpp-master")))]
#[macro_export]
/// Check whether or not cpp is enabled
macro_rules! cpp_is_available {
    () => {
        false
    };
}
#[cfg(any(feature = "c-latest", feature = "c-master"))]
/// Get a `tree_sitter::Language` instance for c
///
/// #### Note
/// Requires the c feature (or one of the c-* features, like c-master)
pub fn get_c() -> tree_sitter::Language {
    extern "C" {
        fn tree_sitter_c() -> tree_sitter::Language;
    }

    unsafe { tree_sitter_c() }
}

#[cfg(not(any(feature = "c-latest", feature = "c-master")))]
/// A stub function which just panics so the type checker passes. This function can be enabled
/// via the c feature flags.
pub fn get_c() -> tree_sitter::Language {
    panic!("c isn't available, to call this function you need to change your feature flags.")
}

#[cfg(any(feature = "c-latest", feature = "c-master"))]
#[macro_export]
/// Check whether or not c is enabled
macro_rules! c_is_available {
    () => {
        true
    };
}

#[cfg(not(any(feature = "c-latest", feature = "c-master")))]
#[macro_export]
/// Check whether or not c is enabled
macro_rules! c_is_available {
    () => {
        false
    };
}
